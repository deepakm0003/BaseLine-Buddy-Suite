/**
 * PR/MR Commenter for Baseline issues
 */

import { ScanResult, CIConfig } from './baseline-checker';

export class PRCommenter {
  /**
   * Generate PR comment with Baseline issues
   */
  generatePRComment(result: ScanResult, config: CIConfig): string {
    const { summary, issues } = result;
    
    let comment = `## ğŸ† Baseline Compliance Check\n\n`;
    
    // Summary
    comment += `### ğŸ“Š Summary\n\n`;
    comment += `- **Files Scanned:** ${result.files.scanned}\n`;
    comment += `- **Files with Issues:** ${result.files.withIssues}\n`;
    comment += `- **Total Issues:** ${summary.total}\n`;
    comment += `- **Errors:** ${summary.errors}\n`;
    comment += `- **Warnings:** ${summary.warnings}\n`;
    comment += `- **Info:** ${summary.info}\n\n`;
    
    // Baseline status
    comment += `### ğŸ“ˆ Baseline Status\n\n`;
    comment += `- **Widely Available:** ${summary.baselineWidely}\n`;
    comment += `- **Newly Available:** ${summary.baselineNewly}\n`;
    comment += `- **Limited Support:** ${summary.total - summary.baselineWidely - summary.baselineNewly}\n\n`;
    
    // Issues
    if (issues.length > 0) {
      comment += `### ğŸ” Issues Found\n\n`;
      
      // Group issues by file
      const issuesByFile = this.groupIssuesByFile(issues);
      
      for (const [file, fileIssues] of issuesByFile) {
        comment += `#### ğŸ“ ${file}\n\n`;
        
        for (const issue of fileIssues) {
          const severity = this.getSeverityIcon(issue.severity);
          const baselineStatus = this.getBaselineStatusText(issue.baseline.baseline);
          
          comment += `- ${severity} **${issue.feature}** (${baselineStatus})\n`;
          comment += `  - Line ${issue.line}: ${issue.message}\n`;
          
          if (issue.suggestion) {
            comment += `  - ğŸ’¡ **Suggestion:** ${issue.suggestion}\n`;
          }
          
          comment += `\n`;
        }
      }
    } else {
      comment += `### âœ… No Issues Found\n\n`;
      comment += `All features are Baseline compliant! ğŸ‰\n\n`;
    }
    
    // Recommendations
    comment += `### ğŸ’¡ Recommendations\n\n`;
    
    if (summary.errors > 0) {
      comment += `- **High Priority:** Fix ${summary.errors} error(s) to ensure browser compatibility\n`;
    }
    
    if (summary.warnings > 0) {
      comment += `- **Medium Priority:** Review ${summary.warnings} warning(s) and consider fallbacks\n`;
    }
    
    if (summary.baselineWidely > 0) {
      comment += `- **Good News:** ${summary.baselineWidely} feature(s) are widely supported! ğŸ‰\n`;
    }
    
    if (summary.baselineNewly > 0) {
      comment += `- **New Features:** ${summary.baselineNewly} feature(s) are newly available - consider adding fallbacks\n`;
    }
    
    // Footer
    comment += `\n---\n`;
    comment += `*This comment was generated by [Baseline Buddy](https://baseline-buddy.dev) - AI-powered Baseline compliance checking.*\n`;
    
    return comment;
  }

  /**
   * Generate summary comment for successful checks
   */
  generateSuccessComment(result: ScanResult): string {
    const { summary } = result;
    
    let comment = `## âœ… Baseline Compliance Check Passed\n\n`;
    comment += `All features are Baseline compliant! ğŸ‰\n\n`;
    comment += `### ğŸ“Š Summary\n\n`;
    comment += `- **Files Scanned:** ${result.files.scanned}\n`;
    comment += `- **Issues Found:** ${summary.total}\n`;
    comment += `- **Widely Available:** ${summary.baselineWidely}\n`;
    comment += `- **Newly Available:** ${summary.baselineNewly}\n\n`;
    comment += `Great job maintaining Baseline compliance! ğŸš€\n\n`;
    comment += `---\n`;
    comment += `*This comment was generated by [Baseline Buddy](https://baseline-buddy.dev)*\n`;
    
    return comment;
  }

  /**
   * Generate error comment for failed checks
   */
  generateErrorComment(result: ScanResult, config: CIConfig): string {
    const { summary } = result;
    
    let comment = `## âŒ Baseline Compliance Check Failed\n\n`;
    comment += `The check failed due to Baseline compliance issues.\n\n`;
    
    if (config.failOnError && summary.errors > 0) {
      comment += `- **Errors:** ${summary.errors} error(s) found\n`;
    }
    
    if (config.failOnWarning && summary.warnings > 0) {
      comment += `- **Warnings:** ${summary.warnings} warning(s) found\n`;
    }
    
    comment += `\nPlease review the issues below and fix them before merging.\n\n`;
    comment += `### ğŸ” Issues Found\n\n`;
    
    // Show top 10 issues
    const topIssues = result.issues.slice(0, 10);
    for (const issue of topIssues) {
      const severity = this.getSeverityIcon(issue.severity);
      const baselineStatus = this.getBaselineStatusText(issue.baseline.baseline);
      
      comment += `- ${severity} **${issue.feature}** (${baselineStatus}) in \`${issue.file}\`\n`;
      comment += `  - ${issue.message}\n`;
      
      if (issue.suggestion) {
        comment += `  - ğŸ’¡ **Suggestion:** ${issue.suggestion}\n`;
      }
      
      comment += `\n`;
    }
    
    if (result.issues.length > 10) {
      comment += `*... and ${result.issues.length - 10} more issues*\n\n`;
    }
    
    comment += `### ğŸ’¡ Next Steps\n\n`;
    comment += `1. Review the issues above\n`;
    comment += `2. Fix the errors and warnings\n`;
    comment += `3. Consider adding fallbacks for newly available features\n`;
    comment += `4. Re-run the Baseline check\n\n`;
    
    comment += `---\n`;
    comment += `*This comment was generated by [Baseline Buddy](https://baseline-buddy.dev)*\n`;
    
    return comment;
  }

  /**
   * Group issues by file
   */
  private groupIssuesByFile(issues: any[]): Map<string, any[]> {
    const grouped = new Map<string, any[]>();
    
    for (const issue of issues) {
      const file = issue.file || 'Unknown';
      if (!grouped.has(file)) {
        grouped.set(file, []);
      }
      grouped.get(file)!.push(issue);
    }
    
    return grouped;
  }

  /**
   * Get severity icon
   */
  private getSeverityIcon(severity: string): string {
    switch (severity) {
      case 'error':
        return 'âŒ';
      case 'warning':
        return 'âš ï¸';
      case 'info':
        return 'â„¹ï¸';
      default:
        return 'â“';
    }
  }

  /**
   * Get Baseline status text
   */
  private getBaselineStatusText(baseline: string | false): string {
    switch (baseline) {
      case 'widely':
        return 'Widely Available';
      case 'newly':
        return 'Newly Available';
      case false:
        return 'Limited Support';
      default:
        return 'Unknown';
    }
  }
}
